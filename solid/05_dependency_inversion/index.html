<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dependency Inversion Principle (DIP)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }
        header {
            background-color: #003049; /* Deeper blue for DIP */
            color: #ffffff;
            padding: 1rem 0;
            text-align: center;
        }
        .container {
            width: 80%;
            margin: 2rem auto;
            padding: 2rem;
            background-color: #ffffff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }
        h1, h2, h3 {
            color: #003049;
        }
        h1 {
            border-bottom: 2px solid #669bbc;
            padding-bottom: 0.5rem;
        }
        h2 {
            color: #669bbc;
            margin-top: 2rem;
        }
        p, li {
            margin-bottom: 1rem;
        }
        code {
            background-color: #e9ecef;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
        }
        pre {
            background-color: #e9ecef;
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 0.9em;
        }
        .example {
            border: 1px solid #dee2e6;
            padding: 1.5rem;
            margin-top: 1.5rem;
            border-radius: 5px;
            background-color: #f8f9fa;
        }
        .bad-example {
            border-left: 5px solid #d62828; /* Red for bad */
        }
        .good-example {
            border-left: 5px solid #fca311; /* Orange for good */
        }
        .interactive-demo {
            margin-top: 2rem;
            padding: 1.5rem;
            border: 1px solid #ced4da;
            border-radius: 5px;
            background-color: #f8f9fa;
        }
        label {
            font-weight: bold;
            margin-right: 10px;
        }
        select, button {
            padding: 0.5rem 1rem;
            border-radius: 4px;
            border: 1px solid #ced4da;
            margin-top: 0.5rem;
        }
        button {
            background-color: #669bbc;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #003049;
        }
        .output {
            margin-top: 1rem;
            padding: 1rem;
            background-color: #e9ecef;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            min-height: 50px;
        }
         .output span {
            display: block;
            margin-bottom: 0.5em;
            padding: 0.3em;
            border-radius: 3px;
        }
        .output .info { background-color: #caf0f8; border-left: 3px solid #0077b6; }
        .output .action { background-color: #e0fbfc; border-left: 3px solid #0a9396; }
        .output .error { background-color: #ffccd5; border-left: 3px solid #d62828; }
        footer {
            text-align: center;
            margin-top: 2rem;
            padding: 1rem;
            background-color: #e9ecef;
            color: #555;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <header>
        <h1>Dependency Inversion Principle (DIP)</h1>
    </header>

    <div class="container">
        <h2>Definition</h2>
        <p>The <strong>Dependency Inversion Principle (DIP)</strong> is a fundamental concept in object-oriented design that promotes loose coupling between software modules. It consists of two key parts:</p>
        <ol>
            <li><strong>High-level modules should not depend on low-level modules. Both should depend on abstractions (e.g., interfaces).</strong></li>
            <li><strong>Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.</strong></li>
        </ol>
        <p>In simpler terms, DIP suggests that instead of high-level components directly using low-level components, both should rely on a common abstraction. This "inverts" the traditional dependency flow where high-level modules directly depend on low-level ones.</p>

        <h2>Why DIP Matters</h2>
        <ul>
            <li><strong>Decoupling:</strong> Reduces the dependency of high-level modules on the specific implementation details of low-level modules.</li>
            <li><strong>Flexibility & Reusability:</strong> Makes it easier to swap out low-level implementations without affecting high-level modules, as long as the new implementation adheres to the abstraction.</li>
            <li><strong>Testability:</strong> Facilitates unit testing by allowing mock implementations of dependencies to be injected.</li>
            <li><strong>Maintainability:</strong> Changes in low-level details are less likely to ripple through the system and break high-level modules.</li>
        </ul>

        <h2>Bad Example: Violating DIP</h2>
        <div class="example bad-example">
            <h3>Scenario: Notification System</h3>
            <p>Consider a <code>NotificationService</code> that directly depends on concrete <code>EmailSender</code> and <code>SMSSender</code> classes.</p>
            <pre><code class="language-javascript">// Low-level Modules (Concrete Implementations)
class EmailSender {
    send(message, recipient) {
        console.log(`Sending email to ${recipient}: ${message}`);
    }
}

class SMSSender {
    send(message, recipient) {
        console.log(`Sending SMS to ${recipient}: ${message}`);
    }
}

// High-level Module
class NotificationService {
    constructor() {
        // Direct dependency on concrete low-level modules
        this.emailSender = new EmailSender();
        this.smsSender = new SMSSender();
    }

    sendNotification(type, message, recipient) {
        if (type === 'email') {
            this.emailSender.send(message, recipient);
        } else if (type === 'sms') {
            this.smsSender.send(message, recipient);
        } // Adding new notification types requires modifying this class
    }
}

// Usage
const notifier = new NotificationService();
notifier.sendNotification('email', 'Hello via Email!', 'user@example.com');
// Problem: NotificationService is tightly coupled to EmailSender and SMSSender.
// Adding a PushNotificationSender would require changing NotificationService.
</code></pre>
            <p>Here, the high-level <code>NotificationService</code> directly creates and uses instances of the low-level <code>EmailSender</code> and <code>SMSSender</code>. This tight coupling makes it difficult to add new notification methods (like push notifications) without modifying <code>NotificationService</code>.</p>
        </div>

        <h2>Good Example: Applying DIP</h2>
        <div class="example good-example">
            <h3>Scenario: Decoupled Notification System</h3>
            <p>We introduce an abstraction (<code>IMessageSender</code> interface) that both high-level and low-level modules depend on. Dependencies are injected instead of being created internally.</p>
            <pre><code class="language-javascript">// Abstraction (Interface)
// Conceptual in JS, often implemented using duck typing or explicit checks
/*
interface IMessageSender {
    send(message, recipient);
}
*/

// Low-level Modules implementing the abstraction
class EmailSender /* implements IMessageSender */ {
    send(message, recipient) {
        console.log(`Sending email to ${recipient}: ${message}`);
        return `Email sent to ${recipient}.`;
    }
}

class SMSSender /* implements IMessageSender */ {
    send(message, recipient) {
        console.log(`Sending SMS to ${recipient}: ${message}`);
        return `SMS sent to ${recipient}.`;
    }
}

class PushNotificationSender /* implements IMessageSender */ {
    send(message, recipient) {
        console.log(`Sending push notification to ${recipient}: ${message}`);
        return `Push notification sent to ${recipient}.`;
    }
}

// High-level Module depending on the abstraction
class NotificationService {
    // Dependency is injected via the constructor
    constructor(messageSenders) { // Expects an object/map of sender instances
        this.messageSenders = messageSenders;
    }

    sendNotification(type, message, recipient) {
        const sender = this.messageSenders[type];
        if (sender && typeof sender.send === 'function') {
           return sender.send(message, recipient);
        } else {
            console.error(`Notification type '${type}' not supported or sender is invalid.`);
            return `Failed to send: type '${type}' not supported.`;
        }
    }
}

// Usage (Dependency Injection)
const senders = {
    email: new EmailSender(),
    sms: new SMSSender(),
    push: new PushNotificationSender() // Easily add new senders
};

const notifier = new NotificationService(senders);
notifier.sendNotification('email', 'DIP rocks!', 'dev@example.com');
notifier.sendNotification('push', 'New feature deployed!', 'user-device-token');
// NotificationService depends on the IMessageSender abstraction,
// not on concrete implementations.
</code></pre>
            <p>Now, <code>NotificationService</code> depends on the <code>IMessageSender</code> abstraction (conceptually). Concrete sender instances are *injected* (passed in), often via the constructor or a setter method (Dependency Injection). This decouples the high-level module from low-level details, allowing new sender types to be added easily without modifying <code>NotificationService</code> itself.</p>
        </div>

        <div class="interactive-demo">
            <h3>Interactive Demo: Ordering System</h3>
            <p>Select a payment method and place an order. The <code>OrderProcessor</code> depends on a <code>IPaymentGateway</code> abstraction, allowing different payment methods (low-level details) to be plugged in.</p>
            <label for="payment-select">Payment Method:</label>
            <select id="payment-select">
                <option value="creditCard">Credit Card</option>
                <option value="paypal">PayPal</option>
                <option value="crypto">Crypto Wallet</option>
            </select>
            <button onclick="processOrder()">Place Order</button>
            <div class="output" id="order-output">Select a payment method and click the button.</div>
        </div>
    </div>

    <footer>
        <p>SOLID Principles Showcase</p>
    </footer>

    <script>
        // --- Abstraction (Conceptual Interface) ---
        // interface IPaymentGateway { processPayment(amount); }

        // --- Low-level Modules (Payment Gateways) ---
        class CreditCardGateway {
            processPayment(amount) {
                console.log(`Processing credit card payment of $${amount}...`);
                return `<span class="action">Processed $${amount} via Credit Card.</span>`;
            }
        }

        class PayPalGateway {
            processPayment(amount) {
                console.log(`Processing PayPal payment of $${amount}...`);
                return `<span class="action">Processed $${amount} via PayPal.</span>`;
            }
        }

        class CryptoWalletGateway {
             processPayment(amount) {
                // Simulate a potential issue for demonstration
                if (amount > 1000) {
                     console.error("Crypto transaction limit exceeded.");
                    return `<span class="error">Crypto payment failed: Amount $${amount} exceeds limit.</span>`;
                }
                console.log(`Processing crypto payment of $${amount}...`);
                return `<span class="action">Processed $${amount} via Crypto Wallet.</span>`;
            }
        }

        // --- High-level Module (Order Processor) ---
        class OrderProcessor {
            constructor(paymentGateway) {
                 if (!paymentGateway || typeof paymentGateway.processPayment !== 'function') {
                    throw new Error("Invalid payment gateway provided.");
                }
                // Depends on the IPaymentGateway abstraction
                this.paymentGateway = paymentGateway;
                this.orderAmount = Math.floor(Math.random() * 1500) + 50; // Random amount for demo
            }

            placeOrder() {
                const info = `<span class="info">Attempting to place order for $${this.orderAmount}...</span>`;
                const result = this.paymentGateway.processPayment(this.orderAmount);
                return info + result;
            }
        }

        // --- Factory/Registry for Gateways ---
        const paymentGateways = {
            creditCard: new CreditCardGateway(),
            paypal: new PayPalGateway(),
            crypto: new CryptoWalletGateway()
        };

        function processOrder() {
            const selectedMethod = document.getElementById('payment-select').value;
            const outputDiv = document.getElementById('order-output');
            const gateway = paymentGateways[selectedMethod];

            if (gateway) {
                try {
                    // Inject the chosen payment gateway dependency
                    const orderProcessor = new OrderProcessor(gateway);
                    outputDiv.innerHTML = orderProcessor.placeOrder();
                } catch (error) {
                    outputDiv.innerHTML = `<span class="error">Error: ${error.message}</span>`;
                }
            } else {
                outputDiv.innerHTML = `<span class="error">Selected payment method is not available.</span>`;
            }
        }

        // Optional: Initial display
        // document.getElementById('order-output').innerHTML = "Select a payment method and click 'Place Order'.";

    </script>

</body>
</html>
