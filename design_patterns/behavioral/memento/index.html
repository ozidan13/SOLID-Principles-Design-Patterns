<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memento Pattern</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #3b82f6; /* Vibrant blue */
            --primary-dark: #2563eb;
            --primary-light: #60a5fa;
            --secondary-color: #10b981; /* Green */
            --secondary-dark: #059669;
            --accent-color: #8b5cf6; /* Purple */
            --accent-color-good: #059669; /* Green for good examples */
            --accent-color-bad: #ef4444; /* Red for bad examples */
            --text-color: #e2e8f0;
            --text-muted: #94a3b8;
            --bg-color: #0f172a; /* Dark blue background */
            --bg-light: #1e293b;
            --bg-lighter: #334155;
            --bg-card: #1e293b;
            --border-color: #334155;
            --code-bg: #0f172a;
            --code-text: #e2e8f0;
            --heading-font: 'Poppins', sans-serif;
            --body-font: 'Inter', sans-serif;
            --border-radius: 8px;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2), 0 2px 4px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
            --glow: 0 0 15px rgba(59, 130, 246, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--body-font);
            line-height: 1.7;
            color: var(--text-color);
            background-color: var(--bg-color);
        }
        
        .hero {
            position: relative;
            min-height: 40vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            overflow: hidden;
            background: linear-gradient(135deg, #0f172a 0%, #1e3a8a 100%);
            padding: 3rem 1rem;
        }

        .hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2000 1500"><rect fill="%23000000" width="2000" height="1500"/><defs><circle stroke="%23222" vector-effect="non-scaling-stroke" id="a" fill="none" stroke-width="5" r="315"/></defs><g transform="translate(1000 750)"><use stroke="%233b82f6" href="%23a" transform="rotate(60 0 0) scale(0.4 0.4)"/><use stroke="%233b82f6" href="%23a" transform="rotate(120 0 0) scale(0.5 0.5)"/><use stroke="%233b82f6" href="%23a" transform="rotate(180 0 0) scale(0.6 0.6)"/><use stroke="%233b82f6" href="%23a" transform="rotate(240 0 0) scale(0.7 0.7)"/><use stroke="%233b82f6" href="%23a" transform="rotate(300 0 0) scale(0.8 0.8)"/></g></svg>');
            background-size: cover;
            opacity: 0.1;
            animation: pulse 15s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.1; }
            50% { transform: scale(1.05); opacity: 0.15; }
            100% { transform: scale(1); opacity: 0.1; }
        }

        .hero-content {
            position: relative;
            z-index: 10;
            max-width: 800px;
        }

        .hero h1 {
            font-family: var(--heading-font);
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(59, 130, 246, 0.5);
        }

        .hero p {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
        }

        /* Shapes animation */
        .shapes {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
        }

        .shape {
            position: absolute;
            opacity: 0.2;
            animation: float 15s infinite linear;
        }

        .shape-1 {
            top: 20%;
            left: 10%;
            width: 60px;
            height: 60px;
            border-radius: 41% 59% 37% 63% / 44% 67% 33% 56%;
            background-color: #10b981;
            animation-duration: 25s;
            box-shadow: 0 0 30px rgba(16, 185, 129, 0.4);
        }

        .shape-2 {
            top: 60%;
            right: 15%;
            width: 80px;
            height: 80px;
            border-radius: 73% 27% 59% 41% / 57% 43% 57% 43%;
            background-color: #8b5cf6;
            animation-duration: 30s;
            animation-delay: 2s;
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.4);
        }

        @keyframes float {
            0% {
                transform: translate(0, 0) rotate(0deg);
            }
            25% {
                transform: translate(10px, 15px) rotate(90deg);
            }
            50% {
                transform: translate(5px, -10px) rotate(180deg);
            }
            75% {
                transform: translate(-10px, 5px) rotate(270deg);
            }
            100% {
                transform: translate(0, 0) rotate(360deg);
            }
        }

        /* Main Content */
        .main-content {
            position: relative;
            margin-top: -50px;
            padding-bottom: 4rem;
        }

        .container {
            width: 90%;
            max-width: 1000px;
            margin: 0 auto;
            padding: 3rem;
            background-color: var(--bg-light);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
        }

        /* Typography */
        h1, h2, h3 {
            font-family: var(--heading-font);
            color: var(--text-color);
        }

        h2 {
            font-size: 1.8rem;
            font-weight: 600;
            margin-top: 3rem;
            margin-bottom: 1.5rem;
            color: var(--primary-light);
        }

        h3 {
            font-size: 1.4rem;
            font-weight: 500;
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        p, li {
            margin-bottom: 1.5rem;
            color: var(--text-muted);
            font-size: 1.05rem;
            line-height: 1.8;
        }

        ul, ol {
            padding-left: 1.5rem;
            margin-bottom: 2rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        strong {
            color: var(--text-color);
            font-weight: 600;
        }

        /* Code styling */
        code {
            background-color: var(--code-bg);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
            color: #f87171;
            border: 1px solid var(--border-color);
        }

        pre {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 1.5rem;
            border-radius: var(--border-radius);
            overflow-x: auto;
            margin: 2rem 0;
            font-size: 0.9rem;
            line-height: 1.6;
            border: 1px solid var(--border-color);
        }

        pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: inherit;
            border: none;
        }

        /* Examples */
        .example {
            border: 1px solid var(--border-color);
            padding: 2rem;
            margin: 2.5rem 0;
            border-radius: var(--border-radius);
            background-color: var(--bg-light);
            box-shadow: var(--shadow-sm);
        }

        .visualization {
            display: flex;
            justify-content: center;
            margin: 2rem 0;
            overflow-x: auto;
            padding: 1rem;
        }

        .visualization svg {
            max-width: 100%;
        }
        
        /* Footer */
        footer {
            background-color: var(--bg-color);
            color: white;
            padding: 3rem 0;
            text-align: center;
            margin-top: 4rem;
            border-top: 1px solid var(--border-color);
        }

        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .footer-content p {
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 0;
        }

        /* Interactive Demo */
        .interactive-demo {
            background-color: var(--bg-lighter);
            padding: 2rem;
            margin: 3rem 0;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
        }

        .interactive-demo h3 {
            margin-top: 0;
            color: var(--primary-light);
        }

        /* Buttons */
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--border-radius);
            font-family: var(--body-font);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
        }

        button:hover {
            background-color: var(--primary-dark);
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.5);
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            background-color: var(--bg-lighter);
            color: var(--text-muted);
            cursor: not-allowed;
        }

        /* Log output */
        .log-output {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            padding: 1.5rem;
            border-radius: var(--border-radius);
            margin-top: 1.5rem;
            height: 200px;
            overflow-y: auto;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .log-entry {
            margin-bottom: 0.5rem;
            border-bottom: 1px dashed var(--border-color);
            padding-bottom: 0.5rem;
        }

        .log-entry:last-child {
            margin-bottom: 0;
            border-bottom: none;
        }
    </style>
</head>
<body>
    <!-- Hero Section -->
    <section class="hero">
        <div class="shapes">
            <div class="shape shape-1"></div>
            <div class="shape shape-2"></div>
        </div>
        <div class="hero-content">
            <h1>Memento Pattern</h1>
            <p>Capture and externalize an object's internal state so it can be restored later</p>
        </div>
    </section>

    <!-- Main Content -->
    <main class="main-content">
        <div class="container">
            <section class="content-section">
                <h2>Understanding the Memento Pattern</h2>
                <p>The Memento pattern is a behavioral design pattern that allows you to capture an object's internal state and save it externally so that the object can be restored to this state later. The pattern is particularly useful when implementing undo mechanisms, history features, or when you need to create snapshots of an object's state.</p>
                
                <h3>Problem</h3>
                <p>Imagine you're implementing a text editor that needs an undo feature. There are several challenges:</p>
                <ul>
                    <li>You need to save the state of objects at different points in time.</li>
                    <li>The saved state must be stored outside the object to avoid exposing its internal structure.</li>
                    <li>Saving the state shouldn't violate encapsulation by exposing private fields and methods.</li>
                    <li>Different types of objects may need different mechanisms for capturing their states.</li>
                </ul>
                
                <h3>Solution</h3>
                <p>The Memento pattern suggests creating a special kind of object that acts as a snapshot of the original object's state. This snapshot is called a "memento." The process works as follows:</p>
                <ul>
                    <li>The <strong>Originator</strong> is the object whose state needs to be saved.</li>
                    <li>The <strong>Memento</strong> is an object that stores a snapshot of the Originator's state.</li>
                    <li>The <strong>Caretaker</strong> is responsible for keeping track of the Mementos, but never modifies their contents.</li>
                </ul>
                <p>The Originator creates a Memento containing a snapshot of its current state. Later, when needed, the Caretaker returns the Memento to the Originator, which uses it to restore its previous state.</p>
                
                <h3>Structure</h3>
                <div class="visualization">
                    <img src="../../images/memento-pattern.svg" alt="Memento Pattern Structure" width="800" height="500">
                </div>
                
                <h3>Participants</h3>
                <ul>
                    <li><strong>Originator:</strong> The class whose state needs to be saved and restored. It creates a memento containing a snapshot of its current state and uses mementos to restore its state.</li>
                    <li><strong>Memento:</strong> A class that stores the internal state of the Originator. The memento should be immutable to prevent unintended modifications.</li>
                    <li><strong>Caretaker:</strong> Responsible for keeping track of multiple mementos. It never examines or modifies the contents of a memento.</li>
                </ul>
                
                <h3>When to Use</h3>
                <p>Use the Memento Pattern when:</p>
                <ul>
                    <li>You need to create snapshots of an object's state to be able to restore it later.</li>
                    <li>You want to implement an undo mechanism.</li>
                    <li>Direct access to an object's fields, getters, and setters would violate its encapsulation.</li>
                    <li>You need to keep a history of changes for later review or analysis.</li>
                </ul>
                
                <h3>Benefits</h3>
                <ul>
                    <li><strong>Preserves Encapsulation:</strong> The memento pattern preserves encapsulation by not exposing the details of the originator's implementation.</li>
                    <li><strong>Simplifies the Originator:</strong> The originator doesn't need to keep track of its history, as that's done by the caretaker.</li>
                    <li><strong>Follows Single Responsibility Principle:</strong> The pattern separates the concerns of state management into different classes.</li>
                    <li><strong>Provides Undo Capability:</strong> Makes it easy to implement undo/redo operations.</li>
                </ul>
                
                <h3>Trade-offs</h3>
                <ul>
                    <li><strong>Memory Usage:</strong> Storing many mementos can consume a lot of memory, especially if the object's state is large or complex.</li>
                    <li><strong>Maintenance Costs:</strong> The caretaker needs to track the lifecycle of mementos and dispose of them when no longer needed.</li>
                    <li><strong>Performance Impact:</strong> Creating and restoring mementos can be expensive for objects with complex state.</li>
                </ul>
                
                <h3>Real-World Uses</h3>
                <ul>
                    <li><strong>Undo/Redo Operations:</strong> Text editors, graphic design applications, and development environments use the memento pattern to implement undo functionality.</li>
                    <li><strong>Transaction Management:</strong> Database systems use mementos to rollback transactions if they fail.</li>
                    <li><strong>Game Saving:</strong> Video games use mementos to save the player's progress and current game state.</li>
                    <li><strong>Version Control:</strong> Software like Git uses a similar concept to track changes to files over time.</li>
                    <li><strong>Wizards and Forms:</strong> Multi-step processes that need to maintain state between steps.</li>
                </ul>
            </section>
            
            <section class="content-section">
                <h2>Implementation Example</h2>
                <p>Let's implement a text editor with an undo feature using the Memento pattern. This will demonstrate how to save and restore states of an object.</p>
                
                <pre><code>/**
 * The Originator class - our text editor
 * This is the class whose state we want to save and restore
 */
class TextEditor {
    constructor() {
        this.content = '';
        this.cursorPosition = 0;
        this.selectionRange = null;
    }
    
    // Methods to modify the state
    type(text) {
        // If there's a selection, replace it
        if (this.selectionRange) {
            const [start, end] = this.selectionRange;
            this.content = this.content.substring(0, start) + 
                          text + 
                          this.content.substring(end);
            this.cursorPosition = start + text.length;
            this.selectionRange = null;
        } else {
            // Otherwise, insert at cursor position
            this.content = this.content.substring(0, this.cursorPosition) + 
                          text + 
                          this.content.substring(this.cursorPosition);
            this.cursorPosition += text.length;
        }
    }
    
    delete() {
        if (this.selectionRange) {
            // Delete the selected text
            const [start, end] = this.selectionRange;
            this.content = this.content.substring(0, start) + 
                          this.content.substring(end);
            this.cursorPosition = start;
            this.selectionRange = null;
        } else if (this.cursorPosition > 0) {
            // Delete one character before cursor
            this.content = this.content.substring(0, this.cursorPosition - 1) + 
                          this.content.substring(this.cursorPosition);
            this.cursorPosition--;
        }
    }
    
    select(start, end) {
        if (start >= 0 && end <= this.content.length && start <= end) {
            this.selectionRange = [start, end];
            this.cursorPosition = end;
        }
    }
    
    // Create a memento that captures the current state
    save() {
        // The memento is returned as an object with the state data
        return new EditorMemento(
            this.content,
            this.cursorPosition,
            this.selectionRange ? [...this.selectionRange] : null
        );
    }
    
    // Restore state from a memento
    restore(memento) {
        if (!memento) return;
        
        this.content = memento.getContent();
        this.cursorPosition = memento.getCursorPosition();
        this.selectionRange = memento.getSelectionRange() 
                            ? [...memento.getSelectionRange()] 
                            : null;
    }
    
    // Method to display current state
    getState() {
        return {
            content: this.content,
            cursorPosition: this.cursorPosition,
            selectionRange: this.selectionRange
        };
    }
}

/**
 * The Memento class
 * Stores the state of the TextEditor
 */
class EditorMemento {
    #content;          // Use private fields for encapsulation
    #cursorPosition;
    #selectionRange;
    
    constructor(content, cursorPosition, selectionRange) {
        this.#content = content;
        this.#cursorPosition = cursorPosition;
        this.#selectionRange = selectionRange;
    }
    
    // These getters are used by the Originator only
    getContent() {
        return this.#content;
    }
    
    getCursorPosition() {
        return this.#cursorPosition;
    }
    
    getSelectionRange() {
        return this.#selectionRange;
    }
}

/**
 * The Caretaker class
 * Manages history and handles undo/redo operations
 */
class EditorHistory {
    constructor(editor) {
        this.editor = editor;
        this.history = [];     // Stack of mementos
        this.currentIndex = -1; // Current position in history
    }
    
    // Save current state to history
    backup() {
        // If we made changes after undoing, truncate the future history
        if (this.currentIndex < this.history.length - 1) {
            this.history = this.history.slice(0, this.currentIndex + 1);
        }
        
        this.history.push(this.editor.save());
        this.currentIndex = this.history.length - 1;
    }
    
    // Restore previous state (undo)
    undo() {
        if (this.currentIndex <= 0) {
            console.log("Nothing to undo.");
            return false;
        }
        
        this.currentIndex--;
        const memento = this.history[this.currentIndex];
        this.editor.restore(memento);
        return true;
    }
    
    // Restore next state (redo)
    redo() {
        if (this.currentIndex >= this.history.length - 1) {
            console.log("Nothing to redo.");
            return false;
        }
        
        this.currentIndex++;
        const memento = this.history[this.currentIndex];
        this.editor.restore(memento);
        return true;
    }
    
    getHistoryInfo() {
        return {
            total: this.history.length,
            current: this.currentIndex + 1
        };
    }
}

// Client code
const editor = new TextEditor();
const history = new EditorHistory(editor);

// Initialize with empty document
history.backup();

// Make some changes
editor.type("Hello, world!");
history.backup();

editor.select(7, 12);  // Select "world"
history.backup();

editor.type("Memento Pattern");
history.backup();

editor.cursorPosition = editor.content.length;  // Move cursor to end
editor.type(" This demonstrates state restoration.");
history.backup();

// Log the document state
console.log("Current state:", editor.getState());

// Undo twice
console.log("Undoing...");
history.undo();
console.log("After first undo:", editor.getState());

console.log("Undoing again...");
history.undo();
console.log("After second undo:", editor.getState());

// Redo
console.log("Redoing...");
history.redo();
console.log("After redo:", editor.getState());
</code></pre>

                <h3>Code Explanation</h3>
                <p>Our implementation showcases the three key components of the Memento pattern:</p>
                
                <ol>
                    <li><strong>Originator (TextEditor):</strong> The class whose state we want to save and restore. It has methods to manipulate text, and importantly, the <code>save()</code> method to create mementos and <code>restore()</code> method to use them.</li>
                    <li><strong>Memento (EditorMemento):</strong> A class that stores the internal state of the originator. Note that we use private fields (with the # prefix) to enforce encapsulation, preventing direct access to the state variables from outside.</li>
                    <li><strong>Caretaker (EditorHistory):</strong> Manages the history of mementos, tracks the current position in history, and provides undo and redo functionality. Importantly, it never examines or modifies the content of the mementos.</li>
                </ol>
                
                <p>This implementation demonstrates several key features of the Memento pattern:</p>
                
                <ul>
                    <li><strong>State Encapsulation:</strong> The state details are kept private within the EditorMemento class.</li>
                    <li><strong>History Management:</strong> The caretaker manages multiple history states and allows navigating through them.</li>
                    <li><strong>Clean Separation of Concerns:</strong> Each class has a clear, single responsibility.</li>
                </ul>
            </section>
            
            <section class="content-section interactive-demo-section">
                <h2>Interactive Demo</h2>
                <p>Experience the Memento pattern in action with this text editor demo. Type in the editor, make selections, and use the undo/redo buttons to navigate through the history of changes.</p>

                <div class="interactive-demo">
                    <style>
                        .editor-container {
                            margin-top: 1.5rem;
                            border: 1px solid var(--border-color);
                            background-color: var(--bg-color);
                            border-radius: var(--border-radius);
                            overflow: hidden;
                        }
                        
                        .editor-toolbar {
                            display: flex;
                            gap: 0.5rem;
                            padding: 0.5rem;
                            background-color: var(--bg-lighter);
                            border-bottom: 1px solid var(--border-color);
                        }
                        
                        .editor-area {
                            min-height: 200px;
                            padding: 1rem;
                            white-space: pre-wrap;
                            font-family: monospace;
                            line-height: 1.5;
                            color: var(--text-color);
                            outline: none;
                        }
                        
                        .editor-cursor {
                            display: inline-block;
                            width: 2px;
                            height: 1.2em;
                            background-color: var(--primary-color);
                            animation: blink 1s step-end infinite;
                            vertical-align: text-bottom;
                            margin-left: -1px;
                        }
                        
                        @keyframes blink {
                            from, to { opacity: 1; }
                            50% { opacity: 0; }
                        }
                        
                        .editor-selection {
                            background-color: rgba(59, 130, 246, 0.3);
                        }
                        
                        .history-info {
                            display: flex;
                            justify-content: space-between;
                            margin-top: 1rem;
                            font-size: 0.9rem;
                            color: var(--text-muted);
                        }
                        
                        .history-timeline {
                            display: flex;
                            gap: 5px;
                            margin-top: 0.5rem;
                            overflow-x: auto;
                            padding-bottom: 0.5rem;
                        }
                        
                        .history-point {
                            width: 15px;
                            height: 15px;
                            border-radius: 50%;
                            background-color: var(--bg-lighter);
                            border: 1px solid var(--border-color);
                            cursor: pointer;
                            flex-shrink: 0;
                            position: relative;
                        }
                        
                        .history-point:hover::after {
                            content: attr(data-snapshot);
                            position: absolute;
                            bottom: 100%;
                            left: 50%;
                            transform: translateX(-50%);
                            background-color: var(--bg-card);
                            padding: 0.25rem 0.5rem;
                            border-radius: 4px;
                            font-size: 0.8rem;
                            white-space: nowrap;
                            z-index: 10;
                            margin-bottom: 5px;
                        }
                        
                        .history-point.active {
                            background-color: var(--primary-color);
                            border-color: var(--primary-color);
                        }
                        
                        .action-btn {
                            background-color: var(--bg-lighter);
                            border: 1px solid var(--border-color);
                            color: var(--text-color);
                            padding: 0.25rem 0.5rem;
                            border-radius: 4px;
                            font-size: 0.9rem;
                            cursor: pointer;
                            transition: all 0.2s;
                        }
                        
                        .action-btn:hover:not(:disabled) {
                            background-color: var(--primary-color);
                            border-color: var(--primary-dark);
                        }
                        
                        .action-btn:disabled {
                            opacity: 0.5;
                            cursor: not-allowed;
                        }
                    </style>
                    
                    <div class="editor-container">
                        <div class="editor-toolbar">
                            <button id="undo-btn" class="action-btn" disabled>Undo</button>
                            <button id="redo-btn" class="action-btn" disabled>Redo</button>
                            <button id="reset-btn" class="action-btn">Reset</button>
                        </div>
                        <div id="editor" class="editor-area" contenteditable="true"></div>
                    </div>
                    
                    <div class="history-info">
                        <span id="history-status">History: 1/1</span>
                        <span id="cursor-position">Cursor: 0</span>
                    </div>
                    
                    <div class="history-timeline" id="history-timeline"></div>
                    
                    <h3 style="margin-top: 2rem;">Internal State:</h3>
                    <pre id="state-display" style="max-height: 150px; overflow-y: auto;"></pre>
                    
                    <script>
                        // Implementation classes (copied from the example above)
                        class TextEditor {
                            constructor() {
                                this.content = '';
                                this.cursorPosition = 0;
                                this.selectionRange = null;
                            }
                            
                            type(text) {
                                if (this.selectionRange) {
                                    const [start, end] = this.selectionRange;
                                    this.content = this.content.substring(0, start) + 
                                                text + 
                                                this.content.substring(end);
                                    this.cursorPosition = start + text.length;
                                    this.selectionRange = null;
                                } else {
                                    this.content = this.content.substring(0, this.cursorPosition) + 
                                                text + 
                                                this.content.substring(this.cursorPosition);
                                    this.cursorPosition += text.length;
                                }
                            }
                            
                            delete() {
                                if (this.selectionRange) {
                                    const [start, end] = this.selectionRange;
                                    this.content = this.content.substring(0, start) + 
                                                this.content.substring(end);
                                    this.cursorPosition = start;
                                    this.selectionRange = null;
                                } else if (this.cursorPosition > 0) {
                                    this.content = this.content.substring(0, this.cursorPosition - 1) + 
                                                this.content.substring(this.cursorPosition);
                                    this.cursorPosition--;
                                }
                            }
                            
                            select(start, end) {
                                if (start >= 0 && end <= this.content.length && start <= end) {
                                    this.selectionRange = [start, end];
                                    this.cursorPosition = end;
                                }
                            }
                            
                            save() {
                                return new EditorMemento(
                                    this.content,
                                    this.cursorPosition,
                                    this.selectionRange ? [...this.selectionRange] : null
                                );
                            }
                            
                            restore(memento) {
                                if (!memento) return;
                                
                                this.content = memento.getContent();
                                this.cursorPosition = memento.getCursorPosition();
                                this.selectionRange = memento.getSelectionRange() 
                                                    ? [...memento.getSelectionRange()] 
                                                    : null;
                            }
                            
                            getState() {
                                return {
                                    content: this.content,
                                    cursorPosition: this.cursorPosition,
                                    selectionRange: this.selectionRange
                                };
                            }
                        }

                        class EditorMemento {
                            #content;
                            #cursorPosition;
                            #selectionRange;
                            
                            constructor(content, cursorPosition, selectionRange) {
                                this.#content = content;
                                this.#cursorPosition = cursorPosition;
                                this.#selectionRange = selectionRange;
                            }
                            
                            getContent() {
                                return this.#content;
                            }
                            
                            getCursorPosition() {
                                return this.#cursorPosition;
                            }
                            
                            getSelectionRange() {
                                return this.#selectionRange;
                            }
                            
                            // For the history timeline display
                            getSnapshot() {
                                const contentPreview = this.#content.length > 15 
                                    ? this.#content.substring(0, 15) + '...' 
                                    : this.#content;
                                return contentPreview || '(empty)';
                            }
                        }

                        class EditorHistory {
                            constructor(editor) {
                                this.editor = editor;
                                this.history = [];
                                this.currentIndex = -1;
                            }
                            
                            backup() {
                                if (this.currentIndex < this.history.length - 1) {
                                    this.history = this.history.slice(0, this.currentIndex + 1);
                                }
                                
                                this.history.push(this.editor.save());
                                this.currentIndex = this.history.length - 1;
                                return this.currentIndex;
                            }
                            
                            undo() {
                                if (this.currentIndex <= 0) {
                                    return false;
                                }
                                
                                this.currentIndex--;
                                const memento = this.history[this.currentIndex];
                                this.editor.restore(memento);
                                return true;
                            }
                            
                            redo() {
                                if (this.currentIndex >= this.history.length - 1) {
                                    return false;
                                }
                                
                                this.currentIndex++;
                                const memento = this.history[this.currentIndex];
                                this.editor.restore(memento);
                                return true;
                            }
                            
                            getHistoryInfo() {
                                return {
                                    total: this.history.length,
                                    current: this.currentIndex + 1
                                };
                            }
                            
                            getHistory() {
                                return {
                                    items: this.history,
                                    currentIndex: this.currentIndex
                                };
                            }
                            
                            jumpTo(index) {
                                if (index >= 0 && index < this.history.length) {
                                    this.currentIndex = index;
                                    const memento = this.history[this.currentIndex];
                                    this.editor.restore(memento);
                                    return true;
                                }
                                return false;
                            }
                            
                            reset() {
                                this.history = [];
                                this.currentIndex = -1;
                                this.editor.content = '';
                                this.editor.cursorPosition = 0;
                                this.editor.selectionRange = null;
                                this.backup();
                            }
                        }

                        // Interactive Demo setup
                        document.addEventListener('DOMContentLoaded', () => {
                            const editorElement = document.getElementById('editor');
                            const undoButton = document.getElementById('undo-btn');
                            const redoButton = document.getElementById('redo-btn');
                            const resetButton = document.getElementById('reset-btn');
                            const historyStatus = document.getElementById('history-status');
                            const cursorPosition = document.getElementById('cursor-position');
                            const stateDisplay = document.getElementById('state-display');
                            const historyTimeline = document.getElementById('history-timeline');
                            
                            const editor = new TextEditor();
                            const history = new EditorHistory(editor);
                            
                            // Initialize with empty document
                            history.backup();
                            updateUI();
                            
                            // Handle text input
                            editorElement.addEventListener('input', (e) => {
                                // Get the new content directly from the contenteditable
                                const newContent = editorElement.textContent || '';
                                
                                // Update the editor model with the new content
                                editor.content = newContent;
                                
                                // Get cursor position
                                const selection = window.getSelection();
                                if (selection.rangeCount > 0) {
                                    const range = selection.getRangeAt(0);
                                    if (range.startContainer === range.endContainer && 
                                        range.startOffset === range.endOffset) {
                                        // Just a cursor, no selection
                                        editor.cursorPosition = range.startOffset;
                                        editor.selectionRange = null;
                                    } else {
                                        // Has selection
                                        editor.selectionRange = [range.startOffset, range.endOffset];
                                        editor.cursorPosition = range.endOffset;
                                    }
                                }
                                
                                // Save state
                                history.backup();
                                updateUI();
                            });
                            
                            // Handle selection changes
                            editorElement.addEventListener('select', () => {
                                const selection = window.getSelection();
                                if (selection.rangeCount > 0) {
                                    const range = selection.getRangeAt(0);
                                    if (range.startContainer === range.endContainer && 
                                        range.startOffset !== range.endOffset) {
                                        editor.selectionRange = [range.startOffset, range.endOffset];
                                        editor.cursorPosition = range.endOffset;
                                        updateUI();
                                    }
                                }
                            });
                            
                            // Handle keydown (for special keys like delete/backspace)
                            editorElement.addEventListener('keydown', (e) => {
                                if (e.key === 'Delete' || e.key === 'Backspace') {
                                    // Let the input event handle this, but make sure
                                    // we backup the state after
                                    setTimeout(() => {
                                        editor.content = editorElement.textContent || '';
                                        history.backup();
                                        updateUI();
                                    }, 0);
                                }
                            });
                            
                            // Undo button
                            undoButton.addEventListener('click', () => {
                                if (history.undo()) {
                                    updateEditorContent();
                                    updateUI();
                                }
                            });
                            
                            // Redo button
                            redoButton.addEventListener('click', () => {
                                if (history.redo()) {
                                    updateEditorContent();
                                    updateUI();
                                }
                            });
                            
                            // Reset button
                            resetButton.addEventListener('click', () => {
                                history.reset();
                                updateEditorContent();
                                updateUI();
                            });
                            
                            // Update contenteditable element with model state
                            function updateEditorContent() {
                                editorElement.textContent = editor.content;
                                
                                // Set cursor or selection
                                const selection = window.getSelection();
                                const range = document.createRange();
                                
                                if (editor.selectionRange) {
                                    const [start, end] = editor.selectionRange;
                                    try {
                                        if (editorElement.firstChild) {
                                            range.setStart(editorElement.firstChild, start);
                                            range.setEnd(editorElement.firstChild, end);
                                        } else {
                                            // Empty editor
                                            range.setStart(editorElement, 0);
                                            range.setEnd(editorElement, 0);
                                        }
                                        selection.removeAllRanges();
                                        selection.addRange(range);
                                    } catch (e) {
                                        console.error("Error setting selection:", e);
                                    }
                                } else {
                                    try {
                                        if (editorElement.firstChild) {
                                            range.setStart(editorElement.firstChild, editor.cursorPosition);
                                            range.collapse(true);
                                        } else {
                                            range.setStart(editorElement, 0);
                                            range.collapse(true);
                                        }
                                        selection.removeAllRanges();
                                        selection.addRange(range);
                                    } catch (e) {
                                        console.error("Error setting cursor:", e);
                                    }
                                }
                            }
                            
                            // Update UI elements (history status, buttons, etc.)
                            function updateUI() {
                                const historyInfo = history.getHistoryInfo();
                                historyStatus.textContent = `History: ${historyInfo.current}/${historyInfo.total}`;
                                cursorPosition.textContent = `Cursor: ${editor.cursorPosition}`;
                                
                                // Update state display
                                stateDisplay.textContent = JSON.stringify(editor.getState(), null, 2);
                                
                                // Update undo/redo buttons
                                undoButton.disabled = historyInfo.current <= 1;
                                redoButton.disabled = historyInfo.current >= historyInfo.total;
                                
                                // Update history timeline
                                updateHistoryTimeline();
                            }
                            
                            // Create visual timeline of history states
                            function updateHistoryTimeline() {
                                historyTimeline.innerHTML = '';
                                
                                const { items, currentIndex } = history.getHistory();
                                items.forEach((memento, index) => {
                                    const point = document.createElement('div');
                                    point.className = 'history-point';
                                    if (index === currentIndex) {
                                        point.classList.add('active');
                                    }
                                    point.setAttribute('data-snapshot', memento.getSnapshot());
                                    point.addEventListener('click', () => {
                                        history.jumpTo(index);
                                        updateEditorContent();
                                        updateUI();
                                    });
                                    historyTimeline.appendChild(point);
                                });
                            }
                        });
                    </script>
                </div>
            </section>
        </div>
    </main>

    <footer>
        <div class="footer-content">
            <p>&copy; 2025 Design Patterns Interactive Guide</p>
        </div>
    </footer>
</body>
</html> 